<?php
/**
* Created by PhpStorm.
 * User: dpino
* Date: 05/06/24
* Time: 11:32AM
*/

namespace Drupal\strawberry_runners\Plugin\StrawberryRunnersPostProcessor;

use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\StreamWrapper\StreamWrapperManager;
use Drupal\strawberryfield\Plugin\search_api\datasource\StrawberryfieldFlavorDatasource;
use Drupal\strawberry_runners\Web64\Nlp\NlpClient;

/**
 *
 * ML YOLO
 *
 * @StrawberryRunnersPostProcessor(
 *    id = "ml_yolo",
 *    label = @Translation("Post processor that generates Object detection and Vector Embeddings using YOLO"),
 *    input_type = "entity:file",
 *    input_property = "filepath",
 *    input_argument = "annotation"
 * )
 */
class MLYoloPostProcessor extends abstractMLPostProcessor {

  public $pluginDefinition;

  /**
   * {@inheritdoc}
   */
  public function defaultConfiguration() {
    return [
        'source_type' => 'asstructure',
        'mime_type' => ['image/jpeg'],
        'output_type' => 'json',
        'output_destination' => 'searchapi',
        'processor_queue_type' => 'background',
        'language_key' => 'language_iso639_3',
        'language_default' => 'eng',
        'timeout' => 300,
        'nlp_url' => 'http://esmero-nlp:6400',
        'ml_method' => '/image/yolov8',
        'use_inherited_region' => FALSE,
      ] + parent::defaultConfiguration();
  }

  public function settingsForm(array $parents, FormStateInterface $form_state) {
    $element = parent::settingsForm($parents, $form_state);
    $element['source_type'] = [
      '#type' => 'select',
      '#title' => $this->t('The type of source data this processor works on'),
      '#options' => [
        'asstructure' => 'File entities referenced in the as:filetype JSON structure',
      ],
      '#default_value' => $this->getConfiguration()['source_type'],
      '#description' => $this->t('Select from where the source data this processor needs is fetched'),
      '#required' => TRUE,
    ];
    $element['ml_method'] = [
      '#type' => 'radios',
      '#title' => $this->t('ML endpoint to use (fixed)'),
      '#options' => [
        '/image/yolo' => 'YOLO (Image Object detection (as MiniOCR Annotations) & embedding as a Unit Length Vector)',
      ],
      '#default_value' => $this->getConfiguration()['ml_method'],
      '#description' => $this->t('The ML endpoint/Model. This is fixed for this processor.'),
      '#required' => TRUE,
    ];
    $element['use_inherited_region'] = [
      '#type' => 'checkbox',
      '#title' => $this->t('Re-use region (detection boundary) from a Parent ML processor for new detection bounding boxes.'),
      '#default_value' => $this->getConfiguration()['use_inherited_region'],
      '#description' => $this->t('If this ML processor is chained (child) of another ML processor the cropped/inherited region (one to many) passed by that processor will be used instead of one or more new detections generated by this. This has no effect if this processor is the root of a chain.'),
      '#required' => FALSE,
    ];
    // Only Images for now.
    $element['jsonkey']['#options'] = [ 'as:image' => 'as:image'];
    return $element;
  }

  protected function runTextMLfromJSON($io, NlpClient $nlpClient): \stdClass {
    $output = new \stdClass();
    return $output;
    // TODO: Implement runTextMLfromJSON() method.
  }

  protected function runImageMLfromIIIF($io, NlpClient $nlpClient): \stdClass {
    $output = new \stdClass();
    $config = $this->getConfiguration();
    $input_argument = $this->pluginDefinition['input_argument'];
    $file_languages = isset($io->input->lang) ? (array) $io->input->lang : [$config['language_default'] ? trim($config['language_default'] ?? '') : 'eng'];
    // Fixed, passed by the AbstractPostProcessor always, even if input_argument is different.
    $sequence_id = isset($io->input->sequence_id) && !is_numeric($io->input->sequence_id) ? $io->input->sequence_id : 1;
    $sequence_number = isset($io->input->sequence_number) && !is_numeric($io->input->sequence_number) ? $io->input->sequence_number : 1;
    $internal_sequence_id = isset($io->input->internal_sequence_id) && !is_numeric($io->input->internal_sequence_id) ? $io->input->internal_sequence_id: 1;
    $annotation = isset($io->input->{$input_argument}) && !is_numeric($io->input->{$input_argument}) ? $io->input->{$input_argument} : '{}';
    $json_annotation = json_decode($annotation, TRUE);
    $iiif_image_url_region = NULL;
    $inherit_region = FALSE;
    if (json_last_error() == JSON_ERROR_NONE) {
      if (!empty($json_annotation)) {
        $iiif_image_url_region = $json_annotation['x'].','.$json_annotation['y'].','.$json_annotation['w']. ','.$json_annotation['h'];
        if ($config['use_inherited_region']) {
          $inherit_region = TRUE;
        }
      }
    }

    setlocale(LC_CTYPE, 'en_US.UTF-8');
    $width = $io->input->metadata['flv:identify'][$io->input->{$input_argument}]['width'] ?? NULL;
    $height = $io->input->metadata['flv:identify'][$io->input->{$input_argument}]['height'] ?? NULL;
    if (!($width && $height)) {
      $width = $io->input->metadata['flv:exif']['ImageWidth'] ?? NULL;
      $height = $io->input->metadata['flv:exif']['ImageHeight'] ?? NULL;
    }
    $iiifidentifier = urlencode(
      StreamWrapperManager::getTarget( isset($io->input->metadata['url']) ? $io->input->metadata['url'] : NULL)
    );

    if ($iiifidentifier == NULL || empty($iiifidentifier) || empty($width) || empty($height)) {
      return $output;
    }

    //@TODO make this a method?
    if (!$iiif_image_url_region) {
      $iiif_image_url_region = 'full';
    }

    $max_dimension = max($width, $height);
    if ($max_dimension <= static::ML_IMAGE_INPUT_SIZE['/image/yolo']) {
      $iiif_image_url_size = 'max';
    }
    else {
      $hratio = ($width/$max_dimension);
      $vratio = ($height/$max_dimension);
      $iiif_image_url_size = '!'. round(floor(static::ML_IMAGE_INPUT_SIZE['/image/yolo'] * $hratio),0).','.round(floor(static::ML_IMAGE_INPUT_SIZE['/image/yolo'] * $vratio),0);
    }
    $quality = $config['iiif_server_image_type'] ?? 'default.jpg';
    $iiif_image_url =  $config['iiif_server']."/{$iiifidentifier}/{$iiif_image_url_region}/{$iiif_image_url_size}/0/{$quality}";
    //@TODO we are not filtering here by label yet. Next release.
    $labels = [];
    $page_text = NULL;
    $output->plugin = NULL;
    $labels = [];
    $ML = $this->callImageML($iiif_image_url,$labels);

    $annotations = [];

    // If we are chaining. And YOLO detects nothing. We should still pass a NO detection annotation. Even if we get no Vector here.


    $output->searchapi['vector_576'] = isset($ML['yolo']['vector']) && is_array($ML['yolo']['vector']) && count($ML['yolo']['vector'])== 576 ? $ML['yolo']['vector'] : NULL;
    if (isset($ML['yolo']['objects']) && is_array($ML['yolo']['objects']) && count($ML['yolo']['objects']) > 0 ) {
      if (!empty($json_annotation)) {
        if (!$inherit_region) {
          foreach ($ML['yolo']['objects'] as &$object) {
            // Rescale based on annotation passed. Yolo's ML annotations are natively in percentage already
            // This also means that we need to cast them back into Pixels relative to the current region,
            // so we can translate, then back to Percent and re-assign in native format.
            // This might be a bit hard?
            // Actual Width sent via IIIF to YOLO
            // $json_annotation['w']
            // Actual height sent via IIIF to YOLO
            // $json_annotation['h']
            // Percentage might be based on that OR on an exact 640 x 640 image?
            // Need to test.
            $current_pixel_x1 = $object['box']['x1'] * $json_annotation['w'];
            $current_pixel_y1 = $object['box']['y1'] * $json_annotation['h'];
            $current_pixel_x2 = $object['box']['x2'] * $json_annotation['w'];
            $current_pixel_y2 = $object['box']['y2'] * $json_annotation['h'];
            $object['box']['x1'] = (($current_pixel_x1 + $json_annotation['x']) / ($width ?? 1));
            $object['box']['x2'] = (($current_pixel_x2 + $json_annotation['x']) / ($width ?? 1));
            $object['box']['y1'] = (($current_pixel_y1 + $json_annotation['y']) / ($height ?? 1));
            $object['box']['y2'] = (($current_pixel_y2 + $json_annotation['y']) / ($height ?? 1));
          }
        }
        else {
          // We can't keep all of them. We need only one. Same as inherited. But we will keep the label and certainty
          $ML['yolo']['objects'] = array_slice($ML['yolo']['objects'],0,1);
          $ML['yolo']['objects'][0]['box']['x1'] = ($json_annotation['x'] / $width);
          $ML['yolo']['objects'][0]['box']['y1'] = ($json_annotation['y'] / $height);
          $ML['yolo']['objects'][0]['box']['x2'] = (($json_annotation['x'] + $json_annotation['w']) / $width) ;
          $ML['yolo']['objects'][0]['box']['y2'] = (($json_annotation['y'] + $json_annotation['h']) / $height);
        }
      }

      $miniocr = $this->yoloToMiniOCR($ML['yolo']['objects'], $width, $height, $sequence_number);
      $annotations = $this->nativeDetectionToAnnotations($ML['yolo']['objects'], $width, $height);
      $output->searchapi['fulltext'] = $miniocr;
      // What is a good confidence ratio here?
      // based on the % of the bounding box?
      // Just the value?
      foreach($ML['yolo']['objects'] as $object) {
        $labels[$object['name']] =  $object['name'];
      }
    }
    elseif (!empty($json_annotation) && isset($output->searchapi['vector_576'])) {
      // Means we got no detection from this child, but we have a vector?
      $ML['yolo']['objects'][0]['box']['x1'] = ($json_annotation['x'] / $width);
      $ML['yolo']['objects'][0]['box']['y1'] = ($json_annotation['y'] / $height);
      $ML['yolo']['objects'][0]['box']['x2'] = (($json_annotation['x'] + $json_annotation['w']) / $width) ;
      $ML['yolo']['objects'][0]['box']['y2'] = (($json_annotation['y'] + $json_annotation['h']) / $height);
      $ML['yolo']['objects'][0]['name'] = $json_annotation['label'] . ' (inherited) ';
      $ML['yolo']['objects'][0]['confidence'] = $json_annotation['confidence'] . ' (inherited) ';
      $labels[$json_annotation['label']] = $json_annotation['label'];
      $miniocr = $this->yoloToMiniOCR($ML['yolo']['objects'], $width, $height, $sequence_number);
      $output->searchapi['fulltext'] = $miniocr;
    }
    $page_text = isset($output->searchapi['fulltext']) ? strip_tags(str_replace("<l>",
      PHP_EOL . "<l> ", $output->searchapi['fulltext'])) : '';

    $output->searchapi['metadata'] = $labels;
    $output->searchapi['service_md5'] = isset($ML['yolo']['modelinfo']) ? md5(json_encode($ML['yolo']['modelinfo'])) : NULL;
    $output->searchapi['plaintext'] = $page_text ?? '';
    $output->searchapi['processlang'] = $file_languages;
    $output->searchapi['ts'] = date("c");
    $output->searchapi['label'] = $this->t("ML Image Embeddings & Vectors") . ' ' . $sequence_number;
    $output->plugin['searchapi'] = $output->searchapi;
    // New. For now reusing 'sequence_number' but we should be really looking for 'annotations' here
    $output->plugin['annotation'] = $annotations;
    return $output;
  }


  protected function yoloToMiniOCR(array $objects, $width, $height, $pageid) {
    $miniocr = new \XMLWriter();
    $miniocr->openMemory();
    $miniocr->startDocument('1.0', 'UTF-8');
    $miniocr->startElement("ocr");
    $atleastone_word = FALSE;
    // To avoid divisions by 0
    $pwidth = (float) $width;
    $pheight = (float) $height;
    // NOTE: floats are in the form of .1 so we need to remove the first 0.
    $miniocr->startElement("p");
    $miniocr->writeAttribute("xml:id", 'ml_yolo_' . $pageid);
    $miniocr->writeAttribute("wh",
      ltrim($pwidth ?? '', 0) . " " . ltrim($pheight ?? '', 0));
    $miniocr->startElement("b");
    foreach ($objects as $object) {
      $notFirstWord = FALSE;
      $miniocr->startElement("l");
      $x0 = (float) $object['box']['x1'];
      $y0 = (float) $object['box']['y1'];
      $x1 = (float) $object['box']['x2'];
      $y1 = (float) $object['box']['y2'];
      $l = ltrim(sprintf('%.3f', $x0)  ?? '', 0);
      $t = ltrim(sprintf('%.3f', $y0) ?? '', 0);
      $w = ltrim(sprintf('%.3f', ($x1 - $x0)) ?? '', 0);
      $h = ltrim(sprintf('%.3f', ($y1 - $y0)) ?? '', 0);
      $text = "ML YOLO : " . (string) ($object['name'] ?? 'Unlabeled') .' ~ '. (string) ("{$object['confidence']}" ?? "0");
      if ($notFirstWord) {
        $miniocr->text(' ');
      }
      $notFirstWord = TRUE;
      // New OCR Highlight does not like empty <w> tags at all
      if (strlen(trim($text ?? '')) > 0) {
        $miniocr->startElement("w");
        $miniocr->writeAttribute("x",
          $l . ' ' . $t . ' ' . $w . ' ' . $h);
        $miniocr->text($text);
        // Only assume we have at least one word for <w> tags
        // Since lines? could end empty?
        $atleastone_word = TRUE;
        $miniocr->endElement();
      }
      $miniocr->endElement();
    }
    $miniocr->endElement();
    $miniocr->endElement();
    $miniocr->endElement();
    $miniocr->endDocument();
    if ($atleastone_word) {
      return $miniocr->outputMemory(TRUE);
    }
    else {
      return StrawberryfieldFlavorDatasource::EMPTY_MINIOCR_XML;
    }
  }

  protected function nativeDetectionToAnnotations(array $objects, $width, $height) {
    $annotations = [];
    //@TODO make the margin configurable? Maybe a %. Reason we add this is bc
    // the bounding box might be too tight for a child processor that is of a
    // different ML type (e.g YOLO -> MobileNet)
   $margin = $this->bb_margin;
    $i = 0;
    // Yolo from API has % coordinates
    foreach ($objects as $object) {
      $i++;
      $x0 = (int) ($object['box']['x1'] * $width) ;
      $y0 = (int) ($object['box']['y1'] * $height);
      $l = $x0  - $margin < 0 ? 0 : $x0 - $margin ;
      $t = $y0  - $margin < 0 ? 0 : $y0 - $margin ;
      $x1 = (int) ($object['box']['x2']  * $width);
      $y1 = (int) ($object['box']['y2']  * $height);
      $r = $x1  + $margin > $width ? $width : $x1  + $margin;
      $b = $y1  + $margin > $height ? $height : $y1   + $margin;
      $w =  ($r - $l);
      $h =  ($b - $t);
      $text = (string) ($object['name'] ?? 'Unlabeled') . ' ~ ' . (string) ("{$object['confidence']}" ?? "0");
      $annotation = [];
      $annotation['label'] = "ML YOLO : " . $text;
      $annotation['confidence'] = $object['confidence'];
      $annotation['model'] = 'yolo';
      $annotation['x'] = (int) floor($l);
      $annotation['y'] = (int) floor($t);
      $annotation['w'] = (int) floor($w);
      $annotation['h'] = (int) floor($h);
      $annotation['id'] = (int) floor($i);
      // We encode to JSON, easier to manage as processor to processor Argument
      $annotations[] = json_encode($annotation);
    }
    return $annotations;
  }



  public function callImageML($image_url, $labels):mixed {
    $nlpClient = $this->getNLPClient();
    $config = $this->getConfiguration();
    $arguments['iiif_image_url'] =  $image_url;
    //@TODO we are not filtering here by label yet. Next release.
    $arguments['labels'] = $labels;
    $ML = $nlpClient->get_call($config['ml_method'],  $arguments, 1);
    return $ML;
  }

  public function callTextML($text, $query):mixed {
    return FALSE;
  }

}
