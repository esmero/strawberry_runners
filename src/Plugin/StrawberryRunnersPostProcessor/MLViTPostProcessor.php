<?php
/**
 * Created by PhpStorm.
 * User: dpino
 * Date: 05/22/24
 * Time: 8:07AM
 */

namespace Drupal\strawberry_runners\Plugin\StrawberryRunnersPostProcessor;

use Drupal\Core\Cache\CacheBackendInterface;
use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\StreamWrapper\StreamWrapperManager;
use Drupal\strawberry_runners\Annotation\StrawberryRunnersPostProcessor;
use Drupal\strawberry_runners\Plugin\StrawberryRunnersPostProcessorPluginInterface;
use Drupal\strawberry_runners\VTTLine;
use Drupal\strawberry_runners\VTTProcessor;
use Drupal\strawberryfield\Plugin\search_api\datasource\StrawberryfieldFlavorDatasource;
use Drupal\strawberry_runners\Web64\Nlp\NlpClient;
use Laracasts\Transcriptions\Transcription;

/**
 *
 * ML ViT
 *
 * @StrawberryRunnersPostProcessor(
 *    id = "ml_vit",
 *    label = @Translation("Post processor that generates Object detection and Vector Embeddings using ViT"),
 *    input_type = "entity:file",
 *    input_property = "filepath",
 *    input_argument = "annotation"
 * )
 */
class MLViTPostProcessor extends abstractMLPostProcessor {

  public $pluginDefinition;

  /**
   * {@inheritdoc}
   */
  public function defaultConfiguration() {
    return [
        'source_type' => 'asstructure',
        'mime_type' => ['image/jpeg'],
        'output_type' => 'json',
        'output_destination' => 'searchapi',
        'processor_queue_type' => 'background',
        'language_key' => 'language_iso639_3',
        'language_default' => 'eng',
        'timeout' => 300,
        'nlp_url' => 'http://esmero-nlp:6400',
        'ml_method' => '/image/vision_transformer',
        'use_inherited_region' => TRUE,
      ] + parent::defaultConfiguration();
  }

  public function settingsForm(array $parents, FormStateInterface $form_state) {
    $element = parent::settingsForm($parents, $form_state);
    $element['source_type'] = [
      '#type' => 'select',
      '#title' => $this->t('The type of source data this processor works on'),
      '#options' => [
        'asstructure' => 'File entities referenced in the as:filetype JSON structure',
      ],
      '#default_value' => $this->getConfiguration()['source_type'],
      '#description' => $this->t('Select from where the source data this processor needs is fetched'),
      '#required' => TRUE,
    ];
    $element['ml_method'] = [
      '#type' => 'radios',
      '#title' => $this->t('ML endpoint to use (fixed)'),
      '#options' => [
        '/image/vision_transformer' => 'ViT (Visual transformer as a Unit Length Vector)',
      ],
      '#default_value' => $this->getConfiguration()['ml_method'],
      '#description' => $this->t('The ML endpoint/Model. This is fixed for this processor.'),
      '#required' => TRUE,
    ];
    $element['use_inherited_region'] = [
      '#type' => 'checkbox',
      '#title' => $this->t('Re-use region (detection boundary) from a Parent ML processor for new detection bounding boxes. Required because ViT do not do region detection'),
      '#default_value' => $this->getConfiguration()['use_inherited_region'],
      '#description' => $this->t('If this ML processor is chained (child) of another ML processor the cropped/inherited region (one to many) passed by that processor will be used instead of one or more new detections generated by this. This has no effect if this processor is the root of a chain.'),
      '#required' => TRUE,
    ];
    // Only Images for now.
    $element['jsonkey']['#options'] = [ 'as:image' => 'as:image'];

    return $element;
  }

  protected function runTextMLfromJSON($io, NlpClient $nlpClient): \stdClass {
    $output = new \stdClass();
    return $output;
    // TODO: Implement runTextMLfromJSON() method.
  }

  protected function runImageMLfromIIIF($io, NlpClient $nlpClient): \stdClass {
    $output = new \stdClass();
    $config = $this->getConfiguration();
    $input_argument = $this->pluginDefinition['input_argument'];
    $file_languages = isset($io->input->lang) ? (array) $io->input->lang : [$config['language_default'] ? trim($config['language_default'] ?? '') : 'eng'];
    // Fixed, passed by the AbstractPostProcessor always, even if input_argument is different.
    $sequence_id = isset($io->input->sequence_id) && !is_numeric($io->input->sequence_id) ? $io->input->sequence_id : 1;
    $sequence_number = isset($io->input->sequence_number) && !is_numeric($io->input->sequence_number) ? $io->input->sequence_number : 1;
    $internal_sequence_id = isset($io->input->internal_sequence_id) && !is_numeric($io->input->internal_sequence_id) ? $io->input->internal_sequence_id: 1;
    $annotation = isset($io->input->{$input_argument}) && !is_numeric($io->input->{$input_argument}) ? $io->input->{$input_argument} : '{}';
    $json_annotation = json_decode($annotation, TRUE);
    $iiif_image_url_region = NULL;
    $inherit_region = FALSE;
    if (json_last_error() == JSON_ERROR_NONE) {
      if (!empty($json_annotation)) {
        $iiif_image_url_region = $json_annotation['x'].','.$json_annotation['y'].','.$json_annotation['w']. ','.$json_annotation['h'];
        if ($config['use_inherited_region']) {
          $inherit_region = TRUE;
        }
        // Now hear me out Diego...
        // because of this the region returned now by this processor will not match the original image.
        // So. What do we do?
        // - A) We adjust/transform pre-cut to global again
        // - B) We ignore the detection boundaries of the Child and use the, passed by the parent, one. Means also transforming $json_annotation back into
        // this native's processor return structure.
      }
    }

    setlocale(LC_CTYPE, 'en_US.UTF-8');
    $width = $io->input->metadata['flv:identify'][$io->input->{$input_argument}]['width'] ?? NULL;
    $height = $io->input->metadata['flv:identify'][$io->input->{$input_argument}]['height'] ?? NULL;
    if (!($width && $height)) {
      $width = $io->input->metadata['flv:exif']['ImageWidth'] ?? NULL;
      $height = $io->input->metadata['flv:exif']['ImageHeight'] ?? NULL;
    }
    $iiifidentifier = urlencode(
      StreamWrapperManager::getTarget( isset($io->input->metadata['url']) ? $io->input->metadata['url'] : NULL)
    );

    if ($iiifidentifier == NULL || empty($iiifidentifier) || empty($width) || empty($height)) {
      return $output;
    }

    if (!$iiif_image_url_region) {
      $iiif_image_url_region = 'full';
    }

    $quality = $config['iiif_server_image_type'] ?? 'default.jpg';
    $iiif_image_url =  $config['iiif_server']."/{$iiifidentifier}/{$iiif_image_url_region}/max/0/{$quality}";

    //@TODO we are not filtering here by label yet. Next release.
    $labels = [];
    $page_text = NULL;
    $output->plugin = NULL;
    $labels = [];
    $ML = $this->callImageML($iiif_image_url,$labels);
    $annotations = [];
    $output->searchapi['vector_768'] = isset($ML['vision_transformer']['vector']) && is_array($ML['vision_transformer']['vector']) && count($ML['vision_transformer']['vector'])== 768 ? $ML['vision_transformer']['vector'] : NULL;
    if (isset($ML['vision_transformer']['objects']) && is_array($ML['vision_transformer']['objects']) && count($ML['vision_transformer']['objects']) > 0 ) {
      if (!empty($json_annotation)) {
        if (!$inherit_region) {
          foreach ($ML['vision_transformer']['objects'] as &$object) {
            // Rescale based on annotation passed
            $object['bounding_box']['origin_x'] = ($json_annotation['x'] / $width) + $object['bounding_box']['origin_x'];
            $object['bounding_box']['origin_y'] = ($json_annotation['y'] / $height) + $object['bounding_box']['origin_y'];
            $object['bounding_box']['width'] = ($json_annotation['w'] / $width) + $object['bounding_box']['width'];
            $object['bounding_box']['height'] = ($json_annotation['h'] / $height) + $object['bounding_box']['height'];
          }
        }
        else {
          // We can't keep all of them. We need only one. Same as inherited. But we will keep the label and certainty
          $ML['vision_transformer']['objects'] = array_slice($ML['vision_transformer']['objects'] ?? [], 0, 1);
          $ML['vision_transformer']['objects'][0]['bounding_box']['origin_x'] = ($json_annotation['x'] / $width);
          $ML['vision_transformer']['objects'][0]['bounding_box']['origin_y'] = ($json_annotation['y'] / $height);
          $ML['vision_transformer']['objects'][0]['bounding_box']['width'] = ($json_annotation['w'] / $width);
          $ML['vision_transformer']['objects'][0]['bounding_box']['height'] = ($json_annotation['h'] / $height);
        }
      }
      $miniocr = $this->vitToMiniOCR($ML['vision_transformer']['objects'], $width, $height, $sequence_number);
      $annotations = $this->nativeDetectionToAnnotations($ML['vision_transformer']['objects'], $width, $height);
      $output->searchapi['fulltext'] = $miniocr;
      // What is a good confidence ratio here?
      // based on the % of the bounding box?
      // Just the value?
      foreach ($ML['vision_transformer']['objects'] as $object) {
        if (isset($object['label'])) {
          $labels[$object['label']] = $object['label'];
        }
      }
    }
    elseif (!empty($json_annotation) && isset($output->searchapi['vector_1024'])) {
      // Means we got no detection from this child, but we have a vector?
      $ML['vision_transformer']['objects'][0]['bounding_box']['origin_x'] = ($json_annotation['x'] / $width);
      $ML['vision_transformer']['objects'][0]['bounding_box']['origin_y'] = ($json_annotation['y'] / $height);
      $ML['vision_transformer']['objects'][0]['bounding_box']['width'] = ($json_annotation['w'] / $width);
      $ML['vision_transformer']['objects'][0]['bounding_box']['height'] = ($json_annotation['h'] / $height);

      $ML['vision_transformer']['objects'][0]['categories'][0]['category_name'] = $json_annotation['label'] . ' (inherited)';
      $ML['vision_transformer']['objects'][0]['categories'][0]['score'] = $json_annotation['confidence'] . ' (inherited)';
      $labels[$json_annotation['label']] = $json_annotation['label'];
      $miniocr = $this->vitToMiniOCR($ML['vision_transformer']['objects'], $width, $height, $sequence_number);
      $output->searchapi['fulltext'] = $miniocr;
    }
    $page_text = isset($output->searchapi['fulltext']) ? strip_tags(str_replace("<l>",
      PHP_EOL . "<l> ", $output->searchapi['fulltext'])) : '';

    $output->searchapi['metadata'] = $labels;
    $output->searchapi['service_md5'] = isset($ML['vision_transformer']['modelinfo']) ? md5(json_encode($ML['vision_transformer']['modelinfo'])) : NULL;
    $output->searchapi['plaintext'] = $page_text ?? '';
    $output->searchapi['processlang'] = $file_languages;
    $output->searchapi['ts'] = date("c");
    $output->searchapi['label'] = $this->t("ViT ML Image Embeddings & Vectors") . ' ' . $sequence_number;
    $output->plugin['searchapi'] = $output->searchapi;
    $output->plugin['annotation'] = $annotations;
    return $output;
  }


  protected function vitToMiniOCR(array $objects, $width, $height, $pageid) {
    $miniocr = new \XMLWriter();
    $miniocr->openMemory();
    $miniocr->startDocument('1.0', 'UTF-8');
    $miniocr->startElement("ocr");
    $atleastone_word = FALSE;
    // To avoid divisions by 0
    $pwidth = (float) $width;
    $pheight = (float) $height;
    // Format here is different. Instead of normalizing on Python we do here?
    // @TODO make all methods in python act the same
    // :[{"bounding_box":{"height":0.9609375,"origin_x":0.0,"origin_y":0.0453125,"width":1.0},"categories":[{"category_name":"person","display_name":null,"index":null,"score":0.8881509304046631}]
    // NOTE: floats are in the form of .1 so we need to remove the first 0.
    $miniocr->startElement("p");
    $miniocr->writeAttribute("xml:id", 'ml_vit_' . $pageid);
    $miniocr->writeAttribute("wh",
      ltrim($pwidth ?? '', 0) . " " . ltrim($pheight ?? '', 0));
    $miniocr->startElement("b");
    foreach ($objects as $object) {
      $notFirstWord = FALSE;
      if ($object['bounding_box'] ?? FALSE) {
        $miniocr->startElement("l");
        $x0 = (float)$object['bounding_box']['origin_x'];
        $y0 = (float)$object['bounding_box']['origin_y'];
        $w = (float)$object['bounding_box']['width'];
        $h = (float)$object['bounding_box']['height'];
        $l = ltrim(sprintf('%.3f', $x0) ?? '', 0);
        $t = ltrim(sprintf('%.3f', $y0) ?? '', 0);
        $w = ltrim(sprintf('%.3f', $w) ?? '', 0);
        $h = ltrim(sprintf('%.3f', $h) ?? '', 0);
        $text = "ML ViT : ";
        $text .= (string)($object['label'] ?? 'Unlabeled') . ' ~ ' . (string)sprintf('%.3f', $object['score'] ?? 0);
        if ($notFirstWord) {
          $miniocr->text(' ');
        }
        $notFirstWord = TRUE;
        // New OCR Highlight does not like empty <w> tags at all
        if (strlen(trim($text ?? '')) > 0) {
          $miniocr->startElement("w");
          $miniocr->writeAttribute("x",
            $l . ' ' . $t . ' ' . $w . ' ' . $h);
          $miniocr->text($text);
          // Only assume we have at least one word for <w> tags
          // Since lines? could end empty?
          $atleastone_word = TRUE;
          $miniocr->endElement();
        }
        $miniocr->endElement();
      }
    }
    $miniocr->endElement();
    $miniocr->endElement();
    $miniocr->endElement();
    $miniocr->endDocument();
    if ($atleastone_word) {
      return $miniocr->outputMemory(TRUE);
    }
    else {
      return StrawberryfieldFlavorDatasource::EMPTY_MINIOCR_XML;
    }
  }

  protected function nativeDetectionToAnnotations(array $objects, $width, $height) {
    $annotations = [];
    //@TODO make the margin configurable? Maybe a %. Reason we add this is bc
    // the bounding box might be too tight for a child processor that is of a
    // different ML type (e.g YOLO -> MobileNet)
    $margin = $this->bb_margin;
    $i = 0;
    // From ViT we want only the first category.
    foreach ($objects as $object) {
      $i++;
      $x0 = (int) ($object['bounding_box']['origin_x'] * $width) ;
      $y0 = (int) ($object['bounding_box']['origin_y'] * $height);
      $l = $x0  - $margin < 0 ? 0 : $x0 - $margin ;
      $t = $y0  - $margin < 0 ? 0 : $y0 - $margin ;
      $w =  $object['bounding_box']['width'] * $width ;
      $h = $object['bounding_box']['height'] * $height ;
      $w = ($w + $margin) > $width ? $width : $w + $margin;
      $h = ($h + $margin) > $height ? $height : $h + $margin;
      $text = (string)($object['label'] ?? 'Unlabeled') . ' ~ ' . (string)sprintf('%.3f', $object['score'] ?? 0);
      $score = $object['score'] ?? 0;
      $annotation = [];
      $annotation['label'] = "ML ViT : " . $text;
      $annotation['confidence'] = $score;
      $annotation['model'] = 'vit';
      $annotation['x'] = (int) floor($l);
      $annotation['y'] = (int) floor($t);
      $annotation['w'] = (int) floor($w);
      $annotation['h'] = (int) floor($h);
      $annotation['id'] = (int) floor($i);
      // We encode to JSON, easier to manage as processor to processor Argument
      $annotations[] = json_encode($annotation);
    }
    return $annotations;
  }




  public function callImageML($image_url, $labels):mixed {
    $nlpClient = $this->getNLPClient();
    $config = $this->getConfiguration();
    $arguments['iiif_image_url'] =  $image_url;
    //@TODO we are not filtering here by label yet. Next release.
    $arguments['labels'] = $labels;
    $ML = $nlpClient->get_call($config['ml_method'],  $arguments, 1);
    return $ML;
  }

  public function callTextML($text, $query):mixed {
    return FALSE;
  }
}
